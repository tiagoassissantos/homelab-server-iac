---
- name: Configure Alpine Linux k3s Server
  hosts: masters
  become: true
  gather_facts: true
  vars:
    ansible_python_interpreter: /usr/bin/python3

  tasks:
    # === System Prerequisites ===
    - name: Update apk cache
      apk:
        update_cache: yes

    - name: Install base packages
      apk:
        name:
          - curl
          - wget
          - git
          - python3
          - py3-pip
          - py3-yaml
          - py3-kubernetes
          - py3-cryptography
          - py3-setuptools
          - openssl
          - ca-certificates
          - iptables
          - ip6tables
          - iptables-legacy
          - cni-plugins
          - containerd
          - runc
          - zsh
          - shadow
          - bash
        state: present

    # === Configure zsh and oh-my-zsh ===
    - name: Change shell to zsh for user
      user:
        name: "{{ ansible_user }}"
        shell: /bin/zsh

    - name: Install oh-my-zsh
      shell: |
        if [ ! -d "/home/{{ ansible_user }}/.oh-my-zsh" ]; then
          su - {{ ansible_user }} -c 'sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended'
        fi
      args:
        creates: "/home/{{ ansible_user }}/.oh-my-zsh"

    - name: Set zsh theme to robbyrussell
      lineinfile:
        path: "/home/{{ ansible_user }}/.zshrc"
        regexp: "^ZSH_THEME="
        line: 'ZSH_THEME="robbyrussell"'
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"

    # === Kernel Modules for k3s ===
    - name: Load required kernel modules
      modprobe:
        name: "{{ item }}"
        state: present
      loop:
        - overlay
        - br_netfilter
        - ip_tables
        - ip6_tables
        - nf_conntrack
        - nf_nat
        - xt_REDIRECT
        - xt_owner
        - iptable_nat
        - iptable_mangle
        - iptable_filter

    - name: Ensure kernel modules load on boot
      lineinfile:
        path: /etc/modules-load.d/k3s.conf
        line: "{{ item }}"
        create: yes
      loop:
        - overlay
        - br_netfilter
        - ip_tables
        - ip6_tables
        - netfilter_conntrack
        - nf_nat
        - xt_REDIRECT
        - xt_owner
        - iptable_nat
        - iptable_mangle
        - iptable_filter

    # === Sysctl settings ===
    - name: Configure sysctl for k3s
      sysctl:
        name: "{{ item.name }}"
        value: "{{ item.value }}"
        sysctl_set: yes
        state: present
        reload: yes
      loop:
        - { name: "net.bridge.bridge-nf-call-iptables", value: "1" }
        - { name: "net.bridge.bridge-nf-call-ip6tables", value: "1" }
        - { name: "net.ipv4.ip_forward", value: "1" }
        - { name: "net.ipv6.conf.all.forwarding", value: "1" }
        - { name: "vm.overcommit_memory", value: "1" }
        - { name: "kernel.panic", value: "10" }
        - { name: "kernel.panic_on_oops", value: "1" }

    # === Configure Firewall ===
    - name: Ensure nftables package is present
      apk:
        name: nftables
        state: present
        update_cache: true

    - name: Ensure nftables include directory exists
      file:
        path: /etc/nftables.d
        state: directory
        mode: "0755"

    - name: Ensure /etc/nftables.conf includes /etc/nftables.d/*.nft
      lineinfile:
        path: /etc/nftables.conf
        regexp: '^include "/etc/nftables.d/\*\.nft";$'
        line: 'include "/etc/nftables.d/*.nft";'
        create: yes

    - name: Install nftables ruleset for K3s/MetalLB
      copy:
        dest: /etc/nftables.d/k3s.nft
        mode: "0644"
        content: |
          table inet k3s {
            chain input {
              type filter hook input priority 0;
              policy drop;

              iif lo accept
              ct state established,related accept

              tcp dport 22 accept

              # Kubernetes API
              tcp dport 6443 accept

              # ICMP/ICMPv6
              meta l4proto { icmp, ipv6-icmp } accept
            }

            chain forward {
              type filter hook forward priority 0;
              policy drop;

              ct state established,related accept

              # Flannel VXLAN
              udp dport 8472 accept

              # Allow pod/service forwarding for kube-proxy
              accept
            }

            chain output {
              type filter hook output priority 0;
              policy accept;
            }
          }

    - name: Enable nftables at boot
      command: rc-update add nftables default
      args:
        creates: /etc/runlevels/default/nftables

    - name: Ensure iptables uses nft backend (Alpine)
      shell: |
        if command -v update-alternatives >/dev/null 2>&1; then
          if [ -e /sbin/iptables-nft ]; then update-alternatives --set iptables /sbin/iptables-nft || true; fi
          if [ -e /sbin/ip6tables-nft ]; then update-alternatives --set ip6tables /sbin/ip6tables-nft || true; fi
        fi

    - name: Remove iptables-legacy if present (to avoid conflicts)
      apk:
        name: iptables-legacy
        state: absent

    - name: Restart nftables to load new rules
      service:
        name: nftables
        state: restarted

    # === Install k3s ===
    - name: Download k3s install script
      get_url:
        url: https://get.k3s.io
        dest: /tmp/k3s-install.sh
        mode: "0755"

    - name: Install k3s server
      shell: |
        INSTALL_K3S_VERSION="{{ k3s_version }}" \
        INSTALL_K3S_CHANNEL="{{ k3s_channel }}" \
        sh /tmp/k3s-install.sh server {{ k3s_install_extra_args }}
      args:
        creates: /usr/local/bin/k3s

    - name: Wait for k3s to be ready
      wait_for:
        port: 6443
        host: localhost
        delay: 30
        timeout: 300

    - name: Create .kube directory
      file:
        path: "/home/{{ ansible_user }}/.kube"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0755"

    - name: Copy k3s kubeconfig
      copy:
        src: /etc/rancher/k3s/k3s.yaml
        dest: "/home/{{ ansible_user }}/.kube/config"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: "0600"
        remote_src: yes

    # === Install Helm ===
    - name: Download Helm install script
      get_url:
        url: https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
        dest: /tmp/get-helm-3.sh
        mode: "0755"

    - name: Install Helm
      shell: /tmp/get-helm-3.sh
      args:
        creates: /usr/local/bin/helm

    # === Install MetalLB ===
    - name: Add MetalLB Helm repository
      kubernetes.core.helm_repository:
        name: metallb
        repo_url: https://metallb.github.io/metallb
        kubeconfig: "/home/{{ ansible_user }}/.kube/config"

    - name: Install MetalLB
      kubernetes.core.helm:
        name: metallb
        chart_ref: metallb/metallb
        release_namespace: metallb-system
        create_namespace: true
        chart_version: "{{ metallb_version }}"
        kubeconfig: "/home/{{ ansible_user }}/.kube/config"

    - name: Wait for MetalLB controller
      kubernetes.core.k8s_info:
        api_version: apps/v1
        kind: Deployment
        name: metallb-controller
        namespace: metallb-system
        kubeconfig: "/home/{{ ansible_user }}/.kube/config"
        wait: true
        wait_condition:
          type: Available
          status: "True"
        wait_timeout: 300

    - name: Create MetalLB IP address pool
      kubernetes.core.k8s:
        kubeconfig: "/home/{{ ansible_user }}/.kube/config"
        definition:
          apiVersion: metallb.io/v1beta1
          kind: IPAddressPool
          metadata:
            name: default-pool
            namespace: metallb-system
          spec:
            addresses:
              - "{{ metallb_address_pool }}"

    - name: Create MetalLB L2Advertisement
      kubernetes.core.k8s:
        kubeconfig: "/home/{{ ansible_user }}/.kube/config"
        definition:
          apiVersion: metallb.io/v1beta1
          kind: L2Advertisement
          metadata:
            name: default-advertise
            namespace: metallb-system
          spec:
            ipAddressPools:
              - default-pool

    # === Install cert-manager ===
    - name: Add cert-manager Helm repository
      kubernetes.core.helm_repository:
        name: jetstack
        repo_url: https://charts.jetstack.io
        kubeconfig: "/home/{{ ansible_user }}/.kube/config"

    - name: Install cert-manager
      kubernetes.core.helm:
        name: cert-manager
        chart_ref: jetstack/cert-manager
        release_namespace: cert-manager
        create_namespace: true
        values:
          installCRDs: true
        kubeconfig: "/home/{{ ansible_user }}/.kube/config"

    - name: Create self-signed ClusterIssuer
      kubernetes.core.k8s:
        kubeconfig: "/home/{{ ansible_user }}/.kube/config"
        definition:
          apiVersion: cert-manager.io/v1
          kind: ClusterIssuer
          metadata:
            name: selfsigned-issuer
          spec:
            selfSigned: {}
      when: tls_mode == "selfsigned"

    # === Install Pi-hole ===
    - name: Create Pi-hole namespace
      kubernetes.core.k8s:
        kubeconfig: "/home/{{ ansible_user }}/.kube/config"
        name: "{{ pihole_namespace }}"
        api_version: v1
        kind: Namespace
        state: present

    - name: Create Pi-hole ConfigMap
      kubernetes.core.k8s:
        kubeconfig: "/home/{{ ansible_user }}/.kube/config"
        definition:
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: pihole-config
            namespace: "{{ pihole_namespace }}"
          data:
            DNS1: "{{ pihole_dns1 }}"
            DNS2: "{{ pihole_dns2 }}"

    - name: Create Pi-hole Secret
      kubernetes.core.k8s:
        kubeconfig: "/home/{{ ansible_user }}/.kube/config"
        definition:
          apiVersion: v1
          kind: Secret
          metadata:
            name: pihole-secret
            namespace: "{{ pihole_namespace }}"
          type: Opaque
          stringData:
            password: "{{ pihole_password }}"

    - name: Deploy Pi-hole
      kubernetes.core.k8s:
        kubeconfig: "/home/{{ ansible_user }}/.kube/config"
        definition:
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: pihole
            namespace: "{{ pihole_namespace }}"
          spec:
            replicas: 1
            selector:
              matchLabels:
                app: pihole
            template:
              metadata:
                labels:
                  app: pihole
              spec:
                containers:
                  - name: pihole
                    image: pihole/pihole:latest
                    env:
                      - name: WEBPASSWORD
                        valueFrom:
                          secretKeyRef:
                            name: pihole-secret
                            key: password
                      - name: DNS1
                        valueFrom:
                          configMapKeyRef:
                            name: pihole-config
                            key: DNS1
                      - name: DNS2
                        valueFrom:
                          configMapKeyRef:
                            name: pihole-config
                            key: DNS2
                      - name: TZ
                        value: "UTC"
                    ports:
                      - containerPort: 80
                        name: http
                      - containerPort: 53
                        name: dns-tcp
                        protocol: TCP
                      - containerPort: 53
                        name: dns-udp
                        protocol: UDP
                    volumeMounts:
                      - name: pihole-data
                        mountPath: /etc/pihole
                      - name: dnsmasq-data
                        mountPath: /etc/dnsmasq.d
                volumes:
                  - name: pihole-data
                    emptyDir: {}
                  - name: dnsmasq-data
                    emptyDir: {}

    - name: Create Pi-hole Service
      kubernetes.core.k8s:
        kubeconfig: "/home/{{ ansible_user }}/.kube/config"
        definition:
          apiVersion: v1
          kind: Service
          metadata:
            name: pihole-service
            namespace: "{{ pihole_namespace }}"
          spec:
            type: LoadBalancer
            loadBalancerIP: "{{ pihole_lb_ip }}"
            ports:
              - port: 80
                targetPort: 80
                name: http
              - port: "{{ pihole_dns_port | int }}"
                targetPort: 53
                name: dns-tcp
                protocol: TCP
              - port: "{{ pihole_dns_port | int }}"
                targetPort: 53
                name: dns-udp
                protocol: UDP
            selector:
              app: pihole

    # === Configure k3s to use Pi-hole as DNS ===
    - name: Configure k3s to use Pi-hole DNS
      lineinfile:
        path: /etc/systemd/resolved.conf
        regexp: "^DNS="
        line: "DNS={{ pihole_lb_ip }}"
        create: yes
      notify: restart systemd-resolved

    - name: Configure coredns to use Pi-hole
      kubernetes.core.k8s:
        kubeconfig: "/home/{{ ansible_user }}/.kube/config"
        definition:
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: coredns
            namespace: kube-system
          data:
            Corefile: |
              .:53 {
                  errors
                  health {
                      lameduck 5s
                  }
                  ready
                  kubernetes cluster.local in-addr.arpa ip6.arpa {
                      pods insecure
                      fallthrough in-addr.arpa ip6.arpa
                      ttl 30
                  }
                  prometheus :9153
                  forward . {{ pihole_lb_ip }}:{{ pihole_dns_port }}
                  cache 30
                  loop
                  reload
                  loadbalance
              }

    # === Install Argo Workflows ===
    - name: Create Argo namespace
      kubernetes.core.k8s:
        kubeconfig: "/home/{{ ansible_user }}/.kube/config"
        name: "{{ argo_namespace }}"
        api_version: v1
        kind: Namespace
        state: present

    - name: Add Argo Helm repository
      kubernetes.core.helm_repository:
        name: argo
        repo_url: https://argoproj.github.io/argo-helm
        kubeconfig: "/home/{{ ansible_user }}/.kube/config"

    - name: Install Argo Workflows
      kubernetes.core.helm:
        name: argo-workflows
        chart_ref: argo/argo-workflows
        release_namespace: "{{ argo_namespace }}"
        chart_version: "{{ argo_chart_version }}"
        values:
          server:
            serviceType: LoadBalancer
            servicePort: 80
            ingress:
              enabled: true
              hosts:
                - host: "{{ argo_host }}"
                  paths:
                    - path: /
                      pathType: Prefix
              tls:
                - secretName: argo-tls
                  hosts:
                    - "{{ argo_host }}"
          workflow:
            serviceAccount:
              create: true
        kubeconfig: "/home/{{ ansible_user }}/.kube/config"

    - name: Create Argo Workflows TLS certificate
      kubernetes.core.k8s:
        kubeconfig: "/home/{{ ansible_user }}/.kube/config"
        definition:
          apiVersion: cert-manager.io/v1
          kind: Certificate
          metadata:
            name: argo-tls
            namespace: "{{ argo_namespace }}"
          spec:
            secretName: argo-tls
            issuerRef:
              name: selfsigned-issuer
              kind: ClusterIssuer
            commonName: "{{ argo_host }}"
            dnsNames:
              - "{{ argo_host }}"

  handlers:
    - name: restart systemd-resolved
      service:
        name: systemd-resolved
        state: restarted
      ignore_errors: true
